(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{457:function(n,e,r){"use strict";r.r(e);var t=r(2),a=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"pika-设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pika-设计"}},[n._v("#")]),n._v(" pika 设计")]),n._v(" "),e("p",[n._v("pika 在设计的时候支持了两种运行模式，即经典模式和分布式模式。")]),n._v(" "),e("table",[e("thead",[e("tr",[e("th",[n._v("模式")]),n._v(" "),e("th",[n._v("原理")])])]),n._v(" "),e("tbody",[e("tr",[e("td",[n._v("经典模式")]),n._v(" "),e("td",[n._v("即一主多从模式，安装 pika 实例维度，即 1 个 pika 实例的数据可以被多个从实例数据同步。")])]),n._v(" "),e("tr",[e("td",[n._v("分布式模式")]),n._v(" "),e("td",[n._v("即用户的数据集合称为 table，将 table 切分成多个分片，每个分片称为 slot，对于某个 key 的数据是由哈希算法计算来决定属于哪个 slot，将所有 slots 及其副本按照一定策略分散到所有的 pika 实例中，每个 pika 实例有一部分的主 slot 和一部分从 slot，主从的维度为 slot。")])])])]),n._v(" "),e("p",[n._v("官网原理图如下")]),n._v(" "),e("p",[n._v("经典模式\n"),e("img",{attrs:{src:"/classic_framework.png",alt:""}})]),n._v(" "),e("p",[n._v("分布式模式"),e("br"),n._v(" "),e("img",{attrs:{src:"/distributed_framework.png",alt:""}})]),n._v(" "),e("p",[n._v("从原理图中，也可以清晰的看出经典模式以实例为维度，分布式模式以 slot 为维度。")]),n._v(" "),e("h2",{attrs:{id:"pika-启动流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pika-启动流程"}},[n._v("#")]),n._v(" pika 启动流程")]),n._v(" "),e("p",[n._v("基于 pika-3.4.0 版本的代码结构，其中 pika 引用了四个第三方的库，分别如下：")]),n._v(" "),e("ol",[e("li",[n._v("Blackwidow，由 piak 自行维护的基于 rocksdb 的存储管理，所有 pika 的数据操作都会通过 blackwidow 的封装最终落入 rocksdb。")]),n._v(" "),e("li",[n._v("Glog，日志库，用于 pika 项目输入不同等级的日志。")]),n._v(" "),e("li",[n._v("Pink，由 pika 自行维护的事件驱动框架，封装了 redis 协议的解析分发功能，并提供回调函数进行处理。")]),n._v(" "),e("li",[n._v("Slash，一些处理工具函数，例如同步的或者数据类型的工具函数。")])]),n._v(" "),e("p",[n._v("启动流程中最主要的几个函数如下：")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('int main(int argc, char *argv[]) {\n  ...\n  LOG(INFO) << "Server at: " << path;\n  g_pika_cmd_table_manager = new PikaCmdTableManager();\n  g_pika_server = new PikaServer();\n  g_pika_rm = new PikaReplicaManager();\n  g_pika_proxy = new PikaProxy();\n\n  if (g_pika_conf->daemonize()) {\n    close_std();\n  }\n\n  g_pika_proxy->Start();\n  g_pika_rm->Start();\n  g_pika_server->Start();\n  ...\n}\n\n')])])]),e("p",[n._v("分为四步，即首先初始化 cmd 的命令，然后初始化 PikaServer，接着初始化 PikaReplicaManager，最后初始化 PikaProxy，主要的启动函数就是如上几步，接着就继续分析一下。")]),n._v(" "),e("h2",{attrs:{id:"pikaserver-功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pikaserver-功能"}},[n._v("#")]),n._v(" PikaServer 功能")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('PikaServer::PikaServer() :\n  exit_(false),\n  slot_state_(INFREE),\n  have_scheduled_crontask_(false),\n  last_check_compact_time_({0, 0}),\n  master_ip_(""),\n  master_port_(0),\n  repl_state_(PIKA_REPL_NO_CONNECT),\n  role_(PIKA_ROLE_SINGLE),\n  last_meta_sync_timestamp_(0),\n  first_meta_sync_(false),\n  loop_partition_state_machine_(false),\n  force_full_sync_(false),\n  slowlog_entry_id_(0) {\n\n  //Init server ip host\n  if (!ServerInit()) {   // 初始化监听的端口和IP\n    LOG(FATAL) << "ServerInit iotcl error";\n  }\n\n  ...\n  InitBlackwidowOptions();   // 初始化Blackwidow的参数项，主要配置rocksdb的相关参数\n\t...\n\n  // Create thread   根据配置来查看有多少的工作线程数\n  worker_num_ = std::min(g_pika_conf->thread_num(),\n                         PIKA_MAX_WORKER_THREAD_NUM);\n\n  std::set<std::string> ips;\n  if (g_pika_conf->network_interface().empty()) {\n    ips.insert("0.0.0.0");\n  } else {\n    ips.insert("127.0.0.1");\n    ips.insert(host_);\n  }\n  // We estimate the queue size    获取处理的队列的大小\n  int worker_queue_limit = g_pika_conf->maxclients() / worker_num_ + 100;\n  LOG(INFO) << "Worker queue limit is " << worker_queue_limit;\n  pika_dispatch_thread_ = new PikaDispatchThread(ips, port_, worker_num_, 3000,\n                                                 worker_queue_limit, g_pika_conf->max_conn_rbuf_size());     // 设置处理响应请求的线程池\n  pika_monitor_thread_ = new PikaMonitorThread();   // 监控的线程池\n  pika_rsync_service_ = new PikaRsyncService(g_pika_conf->db_sync_path(),\n                                             g_pika_conf->port() + kPortShiftRSync);  // 同步的线程池\n  pika_pubsub_thread_ = new pink::PubSubThread();   // 订阅发布处理线程\n  pika_auxiliary_thread_ = new PikaAuxiliaryThread();   // 心跳辅助的状态改变处理线程\n\n  pika_client_processor_ = new PikaClientProcessor(g_pika_conf->thread_pool_size(), 100000);   //  处理异步的task\n\n  pthread_rwlock_init(&state_protector_, NULL);\n  pthread_rwlock_init(&slowlog_protector_, NULL);\n}\n')])])]),e("p",[n._v("这其中初始化了大量的工作线程，来启动协同处理分别启动了 6 个不同的线程池或者线程来进行不同的处理工作。")]),n._v(" "),e("h2",{attrs:{id:"pikadispatchthread"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pikadispatchthread"}},[n._v("#")]),n._v(" PikaDispatchThread")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('PikaDispatchThread::PikaDispatchThread(std::set<std::string> &ips, int port, int work_num,\n                                       int cron_interval, int queue_limit, int max_conn_rbuf_size)\n    : conn_factory_(max_conn_rbuf_size),\n      handles_(this) {\n  thread_rep_ = pink::NewDispatchThread(ips, port, work_num, &conn_factory_,\n                                        cron_interval, queue_limit, &handles_);\n  thread_rep_->set_thread_name("Dispatcher");\n}\n\n...\nprivate:\n  class ClientConnFactory : public pink::ConnFactory {\n   public:\n     explicit ClientConnFactory(int max_conn_rbuf_size)\n         : max_conn_rbuf_size_(max_conn_rbuf_size) {\n     }\n     virtual std::shared_ptr<pink::PinkConn> NewPinkConn(\n        int connfd,\n        const std::string &ip_port,\n        pink::Thread* server_thread,\n        void* worker_specific_data,\n        pink::PinkEpoll* pink_epoll) const {\n       return std::static_pointer_cast<pink::PinkConn>\n         (std::make_shared<PikaClientConn>(connfd, ip_port, server_thread, pink_epoll, pink::HandleType::kAsynchronous, max_conn_rbuf_size_));\n     }\n   private:\n     int max_conn_rbuf_size_;\n    ...\n\n\t...\n  extern ServerThread *NewDispatchThread(\n    const std::set<std::string>& ips, int port,\n    int work_num, ConnFactory* conn_factory,\n    int cron_interval, int queue_limit,\n    const ServerHandle* handle) {\n  return new DispatchThread(ips, port, work_num, conn_factory,\n                            cron_interval, queue_limit, handle);\n  ...\n\n  ...\n  DispatchThread::DispatchThread(const std::set<std::string>& ips, int port,\n                               int work_num, ConnFactory* conn_factory,\n                               int cron_interval, int queue_limit,\n                               const ServerHandle* handle)\n      : ServerThread::ServerThread(ips, port, cron_interval, handle),\n        last_thread_(0),\n        work_num_(work_num),\n        queue_limit_(queue_limit) {\n  worker_thread_ = new WorkerThread*[work_num_];\n  for (int i = 0; i < work_num_; i++) {\n    worker_thread_[i] = new WorkerThread(conn_factory, this, queue_limit, cron_interval); // 生成多个工作线程，工作线程进来的请求通过conn_factory来进行处理\n  }\n}\n\nDispatchThread::~DispatchThread() {\n  for (int i = 0; i < work_num_; i++) {\n    delete worker_thread_[i];\n  }\n  delete[] worker_thread_;\n}\n\nint DispatchThread::StartThread() {\n  for (int i = 0; i < work_num_; i++) { // 根据设置的工作线程的数量来进行处理\n    int ret = handle_->CreateWorkerSpecificData(\n        &(worker_thread_[i]->private_data_));\n    if (ret != 0) {\n      return ret;\n    }\n\n    if (!thread_name().empty()) {\n      worker_thread_[i]->set_thread_name("WorkerThread");\n    }\n    ret = worker_thread_[i]->StartThread();  // 开启每一个工作线程\n    if (ret != 0) {\n      return ret;\n    }\n  }\n  return ServerThread::StartThread();\n}\n...\n')])])]),e("p",[n._v("此时会使用 PikaDispatchThread 的工厂方法来处理新接入的连接，并且每一个新进来的请求通过 NewPinkConn 来进行初始化，并接入处理。其中 DispatchThread 就是位于 pink 的库中实现的方法其中 ServerThread 机会在初始化的过程中进行端口 IP 的监听，在事件响应之后就会调用 HandleNewConn 方法来处理新加入的连接信息，会在处理的过程中进行一个轮训的操作来分配到工作线程，在加入事件之后就会通过新生成一个 PikaClientConn 来进行事件处理，当 pink 中的 redisconn 解析到了完整的命令的时候就会调用 PikaClientConn 的 ProcessRedisCmds 方法来处理（中间的逻辑有点复杂大家有兴趣可以自行查找源码阅读一下）。")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('void PikaClientConn::ProcessRedisCmds(const std::vector<pink::RedisCmdArgsType>& argvs, bool async, std::string* response) {\n  if (async) {   // 是否是后台任务\n    BgTaskArg* arg = new BgTaskArg();  // 新建一个后台任务\n    arg->redis_cmds = argvs;\n    arg->conn_ptr = std::dynamic_pointer_cast<PikaClientConn>(shared_from_this());\n    g_pika_server->ScheduleClientPool(&DoBackgroundTask, arg);  // 放入PikaClientProcessor的线程池来进行处理\n    return;\n  }\n  BatchExecRedisCmd(argvs);  // 如果不是则调用响应的线程池直接处理\n}\n\n...\nvoid PikaClientConn::BatchExecRedisCmd(const std::vector<pink::RedisCmdArgsType>& argvs) {\n  resp_num.store(argvs.size());\n  for (size_t i = 0; i < argvs.size(); ++i) {  // 根据解析的输入参数大小来处理\n    std::shared_ptr<std::string> resp_ptr = std::make_shared<std::string>();\n    resp_array.push_back(resp_ptr);\n    ExecRedisCmd(argvs[i], resp_ptr);   // 处理对应的命令\n  }\n  TryWriteResp();\n}\n...\nvoid PikaClientConn::ExecRedisCmd(const PikaCmdArgsType& argv, std::shared_ptr<std::string> resp_ptr) {\n  // get opt\n  std::string opt = argv[0];\n  slash::StringToLower(opt);\n  if (opt == kClusterPrefix) {   // 检查是否是集群名称开头\n    if (argv.size() >= 2 ) {\n      opt += argv[1];\n      slash::StringToLower(opt);\n    }\n  }\n\n  std::shared_ptr<Cmd> cmd_ptr = DoCmd(argv, opt, resp_ptr);  // 执行命令\n  // level == 0 or (cmd error) or (is_read)\n  if (g_pika_conf->consensus_level() == 0 || !cmd_ptr->res().ok() || !cmd_ptr->is_write()) {\n    *resp_ptr = std::move(cmd_ptr->res().message());\n    resp_num--;\n  }\n}\n...\n\nstd::shared_ptr<Cmd> PikaClientConn::DoCmd(\n    const PikaCmdArgsType& argv,\n    const std::string& opt,\n    std::shared_ptr<std::string> resp_ptr) {\n  // Get command info\n  std::shared_ptr<Cmd> c_ptr = g_pika_cmd_table_manager->GetCmd(opt);   // 从命令列表中查找命令\n  if (!c_ptr) {\n    std::shared_ptr<Cmd> tmp_ptr = std::make_shared<DummyCmd>(DummyCmd());\n    tmp_ptr->res().SetRes(CmdRes::kErrOther,\n        "unknown or unsupported command \\\'" + opt + "\\"");\n    return tmp_ptr;\n  }\n  c_ptr->SetConn(std::dynamic_pointer_cast<PikaClientConn>(shared_from_this()));\n  c_ptr->SetResp(resp_ptr);\n\n  // Check authed\n  // AuthCmd will set stat_\n  if (!auth_stat_.IsAuthed(c_ptr)) {   // 检查是否认证\n    c_ptr->res().SetRes(CmdRes::kErrOther, "NOAUTH Authentication required.");\n    return c_ptr;\n  }\n\n  uint64_t start_us = 0;\n  if (g_pika_conf->slowlog_slower_than() >= 0) {\n    start_us = slash::NowMicros();\n  }\n\n  bool is_monitoring = g_pika_server->HasMonitorClients();  // 是否是监控的客户端\n  if (is_monitoring) {\n    ProcessMonitor(argv);\n  }\n\n  // Initial\n  c_ptr->Initial(argv, current_table_);  // 初始化命令信息\n  if (!c_ptr->res().ok()) {\n    return c_ptr;\n  }\n\n  g_pika_server->UpdateQueryNumAndExecCountTable(current_table_, opt, c_ptr->is_write());\n\n  // PubSub connection\n  // (P)SubscribeCmd will set is_pubsub_\n  if (this->IsPubSub()) {\n    if (opt != kCmdNameSubscribe &&\n        opt != kCmdNameUnSubscribe &&\n        opt != kCmdNamePing &&\n        opt != kCmdNamePSubscribe &&\n        opt != kCmdNamePUnSubscribe) {\n      c_ptr->res().SetRes(CmdRes::kErrOther,\n          "only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT allowed in this context");\n      return c_ptr;\n    }\n  }\n\n  if (g_pika_conf->consensus_level() != 0 && c_ptr->is_write()) {\n    c_ptr->SetStage(Cmd::kBinlogStage);\n  }\n  if (!g_pika_server->IsCommandSupport(opt)) {\n    c_ptr->res().SetRes(CmdRes::kErrOther,\n        "This command is not supported in current configuration");\n    return c_ptr;\n  }\n\n  if (!g_pika_server->IsTableExist(current_table_)) {\n    c_ptr->res().SetRes(CmdRes::kErrOther, "Table not found");\n    return c_ptr;\n  }\n\n  // TODO: Consider special commands, like flushall, flushdb?\n  if (c_ptr->is_write()) {\n    if (g_pika_server->IsTableBinlogIoError(current_table_)) {\n      c_ptr->res().SetRes(CmdRes::kErrOther, "Writing binlog failed, maybe no space left on device");\n      return c_ptr;\n    }\n    std::vector<std::string> cur_key = c_ptr->current_key();\n    if (cur_key.empty()) {\n      c_ptr->res().SetRes(CmdRes::kErrOther, "Internal ERROR");\n      return c_ptr;\n    }\n    if (g_pika_server->readonly(current_table_, cur_key.front())) {\n      c_ptr->res().SetRes(CmdRes::kErrOther, "Server in read-only");\n      return c_ptr;\n    }\n    if (!g_pika_server->ConsensusCheck(current_table_, cur_key.front())) {\n      c_ptr->res().SetRes(CmdRes::kErrOther, "Consensus level not match");\n    }\n  }\n\n  // Process Command   执行命令\n  c_ptr->Execute();\n\n  if (g_pika_conf->slowlog_slower_than() >= 0) {\n    ProcessSlowlog(argv, start_us);\n  }\n  if (g_pika_conf->consensus_level() != 0 && c_ptr->is_write()) {\n    c_ptr->SetStage(Cmd::kExecuteStage);\n  }\n\n  return c_ptr;\n}\n...\n')])])]),e("p",[n._v("通过层层的调用关系最终调用到了 Cmd 类的 Do 方法，例如 SetCmd 的执行流程如下：")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("void SetCmd::Do(std::shared_ptr<Partition> partition) {\n  rocksdb::Status s;\n  int32_t res = 1;\n  switch (condition_) {\n    case SetCmd::kXX:\n      s = partition->db()->Setxx(key_, value_, &res, sec_);  // 通过db来设置key相关的信息\n      break;\n    case SetCmd::kNX:\n      s = partition->db()->Setnx(key_, value_, &res, sec_);\n      break;\n    case SetCmd::kVX:\n      s = partition->db()->Setvx(key_, target_, value_, &success_, sec_);\n      break;\n    case SetCmd::kEXORPX:\n      s = partition->db()->Setex(key_, value_, sec_);\n      break;\n    default:\n      s = partition->db()->Set(key_, value_);\n      break;\n  }\n\n  if (s.ok() || s.IsNotFound()) {\n    if (condition_ == SetCmd::kVX) {\n      res_.AppendInteger(success_);\n    } else {\n      if (res == 1) {\n        res_.SetRes(CmdRes::kOk);\n      } else {\n        res_.AppendArrayLen(-1);;\n      }\n    }\n  } else {\n    res_.SetRes(CmdRes::kErrOther, s.ToString());\n  }\n}\n")])])]),e("p",[n._v("至此就是通过一个简单的 set 命令来进行的流程，当然中间省略了很多复杂的交互细节，并且跳过了 pink 库的一个处理流程，最终会回调在 pika 中的 ProcessRedisCmds 处理。")]),n._v(" "),e("h3",{attrs:{id:"pikaclientprocessor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pikaclientprocessor"}},[n._v("#")]),n._v(" PikaClientProcessor")]),n._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('PikaClientProcessor::PikaClientProcessor(\n    size_t worker_num, size_t max_queue_size, const std::string& name_prefix) {\n  pool_ = new pink::ThreadPool(\n      worker_num, max_queue_size, name_prefix + "Pool");   // 生成一个线程池\n  for (size_t i = 0; i < worker_num; ++i) {   \t\t\t// 根据设置的线程池数量来初始化\n    pink::BGThread* bg_thread = new pink::BGThread(max_queue_size);  // 初始化bg工作线程\n    bg_threads_.push_back(bg_thread);         \t// 保存每个线程\n    bg_thread->set_thread_name(name_prefix + "BgThread");\n  }\n}\n')])])]),e("p",[n._v("主要是生成线程池来进行后台运行。在上一节中分析的 task 就是交给了 pool_线程池来进行数据的处理。一些协调数据同步的工作就交给了 bg_threads 线程池处理。")]),n._v(" "),e("p",[e("img",{attrs:{src:"/pika_threads.png",alt:""}})]),n._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),e("p",[n._v("本文主要简单的描述了有关 piak 的总体设计框架（参考官网架构），简单的通过 PikaServer 的启动过程来描述了一下基础的处理逻辑，因为这其中涉及到大量的细节故并没有详尽的去分析，并且也没有涉及到其他的功能比如 slot 的数据一致性保证等等细节，后续有继续再继续查阅相关内容。由于本人才疏学浅，如有错误请批评指正。")])])}),[],!1,null,null,null);e.default=a.exports}}]);